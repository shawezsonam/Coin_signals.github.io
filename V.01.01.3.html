
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Crypto Signal Dashboard</title>
    
    <script src="https://s3.tradingview.com/tv.js"></script>
    
    <style>
        /* Base Styles */
        body {
            font-family: 'Arial', sans-serif;
            background-color: #0e1117;
            color: #d1d5db;
            margin: 0;
            padding: 20px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #374151;
        }
        .header h1 {
            font-size: 1.5rem;
            margin: 0;
            color: #6366f1;
        }
        .header select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #374151;
            background-color: #1f2937;
            color: #d1d5db;
            font-size: 1rem;
        }

        /* Dashboard Grid Layout */
        #dashboard {
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .card-row {
            background-color: #1f2937;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            border-left: 5px solid #4b5563;
            position: relative;
        }

        /* Strong State Visuals */
        .card-row.strong-buy, .card-row.very-strong-buy, .card-row.ultra-strong-buy { border-left-color: #10b981; }
        .card-row.strong-sell, .card-row.very-strong-sell, .card-row.ultra-strong-sell { border-left-color: #ef4444; }
        .card-row.ultra-strong-buy { box-shadow: 0 0 10px #10b981; }
        .card-row.ultra-strong-sell { box-shadow: 0 0 10px #ef4444; }

        /* Time and Timer */
        .time-label {
            font-size: 1.2rem;
            font-weight: bold;
            color: #9ca3af;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
        }
        .strong-timer {
            font-size: 0.9rem;
            color: #6366f1;
            margin-bottom: 10px;
            text-align: center;
        }

        /* Metrics and Values */
        .metric-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
            border-bottom: 1px dashed #374151;
            padding-bottom: 10px;
        }
        .metric-item {
            display: flex;
            align-items: center;
            flex: 0 0 calc(50% - 4px);
            font-size: 0.9rem;
        }
        .metric-item .label {
            font-weight: 500;
            color: #9ca3af;
            margin-right: 4px;
        }
        .metric-item .value {
            font-weight: bold;
            color: #d1d5db;
        }

        /* Signal Badges */
        .signal {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 5px;
        }
        .yellow { background-color: #f59e0b; color: #1f2937; }
        .green { background-color: #10b981; color: #1f2937; }
        .red { background-color: #ef4444; color: #1f2937; }
        .very-strong-buy { background-color: #1e40af; color: #bfdbfe; border: 1px solid #3b82f6; }
        .very-strong-sell { background-color: #991b1b; color: #fecaca; border: 1px solid #ef4444; }
        .ultra-strong-green { background-color: #059669; color: #ecfdf5; border: 2px solid #10b981; }
        .ultra-strong-red { background-color: #b91c1c; color: #fee2e2; border: 2px solid #ef4444; }

        /* Multi-Timeframe Confirmation Badges */
        .multi-tf-confirm {
            background-color: #facc15;
            color: #1f2937;
            font-size: 0.7rem;
            padding: 2px 4px;
            border-radius: 4px;
            margin-left: 5px;
            font-weight: bold;
        }
        .all-tf-confirm {
            background-color: #34d399;
            color: #064e3b;
            font-size: 0.7rem;
            padding: 2px 4px;
            border-radius: 4px;
            margin-left: 5px;
            font-weight: bold;
        }

        /* TradingView Chart */
        .chart-container {
            height: 300px;
            background-color: #0e1117;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        #status {
            font-size: 0.8rem;
            color: #9ca3af;
            margin-top: 20px;
            text-align: center;
        }

        /* Signal Details Feature Styles */
        .details-button {
            background-color: #374151;
            color: #d1d5db;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background-color 0.2s;
            float: right;
            margin-top: -30px;
        }
        .details-button:hover {
            background-color: #4b5563;
        }
        .signal-details-container {
            margin-top: 10px;
            padding: 10px;
            background-color: #0e1117;
            border-radius: 4px;
            border-top: 1px dashed #374151;
            display: none;
        }
        .signal-details-container.show {
            display: block;
        }
        .signal-details-container h4 {
            margin: 8px 0 5px 0;
            color: #6366f1;
            font-size: 1rem;
            border-bottom: 1px solid #1f2937;
            padding-bottom: 2px;
        }
        .signal-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        .signal-item {
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
        }
        .signal-item.buy { color: #10b981; }
        .signal-item.sell { color: #ef4444; }
        .signal-item .conf { font-weight: bold; }

        /* API Source Badge */
        .api-badge {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 5px;
            background-color: #6366f1;
            color: white;
        }
    </style>
</head>
<body>
     <div class="header">
        <h1>Ultimate Crypto Signal Dashboard</h1>
        <div class="controls">
            <select id="coinSelect"></select>
            <select id="apiSelect">
                <option value="binance">Binance (1200/min)</option>
                <option value="coincap">CoinCap (200/min)</option>
                <option value="kraken">Kraken (180/min)</option>
                <option value="huobi">Huobi (150/min)</option>
                <option value="okx">OKX (120/min)</option>
            </select>
        </div>
    </div>

    <div id="dashboard"></div>

    <div id="status">Loading...</div>

    <script>
        // Configuration
        const coins = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT', 'ADAUSDT', 'DOGEUSDT', 'AVAXUSDT', 'MATICUSDT', 'LTCUSDT'];
        const timeframes = ['1m', '5m', '15m', '30m', '1h', '4h']; 
        const usdToInr = 87.60;

        // Global Variables
        let selectedCoin = 'BTCUSDT';
        let selectedAPI = 'binance';
        let tvWidgets = {};
        let currentPrice = 0;
        let strongState = {};
        let tickCounter = 0;
        let multiTimeframeSignals = {};
        let allSignalsData = {};

        // DOM Elements
        const coinSelect = document.getElementById('coinSelect');
        const apiSelect = document.getElementById('apiSelect');
        const dashboard = document.getElementById('dashboard');
        const statusEl = document.getElementById('status');

        // API Endpoints Configuration
        const apiEndpoints = {
            binance: {
                name: 'Binance',
                klines: (symbol, interval, limit) => 
                    `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`,
                limit: 1200
            },
            coincap: {
                name: 'CoinCap',
                klines: (symbol, interval, limit) => {
                    const coinId = symbol.replace('USDT', '').toLowerCase();
                    return `https://api.coincap.io/v2/assets/${coinId}/history?interval=m1&limit=${limit}`;
                },
                limit: 200
            },
            kraken: {
                name: 'Kraken',
                klines: (symbol, interval, limit) => {
                    const pair = symbol.replace('USDT', 'USD');
                    return `https://api.kraken.com/0/public/OHLC?pair=${pair}&interval=1&limit=${limit}`;
                },
                limit: 180
            },
            huobi: {
                name: 'Huobi',
                klines: (symbol, interval, limit) => {
                    const pair = symbol.toLowerCase();
                    return `https://api.huobi.pro/market/history/kline?symbol=${pair}&period=1min&size=${limit}`;
                },
                limit: 150
            },
            okx: {
                name: 'OKX',
                klines: (symbol, interval, limit) => {
                    const instId = symbol.replace('USDT', '-USDT');
                    return `https://www.okx.com/api/v5/market/candles?instId=${instId}&bar=1m&limit=${limit}`;
                },
                limit: 120
            }
        };

        // Utility Functions
        function sma(arr) {
            return arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
        }

        function calculateRSI(closes, period = 14) {
            if (closes.length < period + 1) return 50;
            
            let gains = 0, losses = 0;
            for (let i = closes.length - period; i < closes.length; i++) {
                const diff = closes[i] - closes[i - 1];
                if (diff > 0) gains += diff;
                else losses -= diff;
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            if (avgLoss === 0) return 100;
            
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        function calculateEMA(prices, period) {
            if (prices.length < period) return prices.at(-1) || 0;
            
            const k = 2 / (period + 1);
            let ema = prices[0];
            
            for (let i = 1; i < prices.length; i++) {
                ema = prices[i] * k + ema * (1 - k);
            }
            return ema;
        }

        function calculateMACD(closes) {
            if (closes.length < 26) return { macd: 0, signal: 0, histogram: 0 };
            
            const ema12 = calculateEMA(closes.slice(-26), 12);
            const ema26 = calculateEMA(closes.slice(-26), 26);
            const macd = ema12 - ema26;
            const signal = calculateEMA([macd], 9);
            
            return { macd, signal, histogram: macd - signal };
        }

        function calculateStochastic(highs, lows, closes, period = 14) {
            if (closes.length < period) return { k: 50, d: 50 };
            
            const currentLow = Math.min(...lows.slice(-period));
            const currentHigh = Math.max(...highs.slice(-period));
            const k = ((closes.at(-1) - currentLow) / (currentHigh - currentLow)) * 100;
            
            const kValues = [];
            for (let i = closes.length - period; i < closes.length; i++) {
                const periodLow = Math.min(...lows.slice(i - period + 1, i + 1));
                const periodHigh = Math.max(...highs.slice(i - period + 1, i + 1));
                const kVal = ((closes[i] - periodLow) / (periodHigh - periodLow)) * 100;
                kValues.push(kVal);
            }
            
            const d = sma(kValues.slice(-3));
            return { k, d };
        }

        function calculateBollingerBands(closes, period = 20) {
            if (closes.length < period) return { upper: 0, middle: 0, lower: 0, width: 0 };
            
            const smaVal = sma(closes.slice(-period));
            const variance = closes.slice(-period).reduce((acc, price) => 
                acc + Math.pow(price - smaVal, 2), 0) / period;
            const stdDev = Math.sqrt(variance);
            
            return {
                upper: smaVal + (stdDev * 2),
                middle: smaVal,
                lower: smaVal - (stdDev * 2),
                width: (stdDev * 4) / smaVal * 100
            };
        }

        function calculateWilliamsR(highs, lows, closes, period = 14) {
            if (closes.length < period) return -50;
            
            const highestHigh = Math.max(...highs.slice(-period));
            const lowestLow = Math.min(...lows.slice(-period));
            return ((highestHigh - closes.at(-1)) / (highestHigh - lowestLow)) * -100;
        }

        function calculateCCI(highs, lows, closes, period = 20) {
            if (closes.length < period) return 0;
            
            const typicalPrices = [];
            for (let i = closes.length - period; i < closes.length; i++) {
                typicalPrices.push((highs[i] + lows[i] + closes[i]) / 3);
            }
            
            const smaTP = sma(typicalPrices);
            const meanDeviation = typicalPrices.reduce((sum, tp) => 
                sum + Math.abs(tp - smaTP), 0) / period;
            
            return (typicalPrices.at(-1) - smaTP) / (0.015 * meanDeviation);
        }

        function calculateOBV(closes, volumes) {
            if (closes.length === 0) return 0;
            let obv = volumes[0] || 0;
            for (let i = 1; i < closes.length; i++) {
                if (closes[i] > closes[i - 1]) 
                    obv += volumes[i];
                else if (closes[i] < closes[i - 1]) 
                    obv -= volumes[i];
            }
            return obv;
        }

        function signalBadge(text, cls) {
            return `<span class="signal ${cls}">${text}</span>`;
        }

        function apiBadge(apiName) {
            return `<span class="api-badge">${apiName}</span>`;
        }

        async function fetchWithRetry(url, retries = 3, delay = 500) {
            for (let i = 0; i < retries; i++) {
                let timeoutId;
                try {
                    const controller = new AbortController();
                    timeoutId = setTimeout(() => controller.abort(), 8000);
                    const res = await fetch(url, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    if (!res.ok) throw new Error('HTTP ' + res.status);
                    return await res.json();
                } catch (e) {
                    if (timeoutId) clearTimeout(timeoutId);
                    if (i === retries - 1) throw e;
                    await new Promise(r => setTimeout(r, delay * (i + 1)));
                }
            }
        }

        // Universal Klines Fetcher
        async function fetchKlines(interval = '1m', limit = 500) {
            const api = apiEndpoints[selectedAPI];
            const url = api.klines(selectedCoin, interval, limit);
            
            try {
                const data = await fetchWithRetry(url);
                
                // Parse different API responses
                switch(selectedAPI) {
                    case 'binance':
                        return data.map(c => ({
                            openTime: c[0],
                            open: +c[1],
                            high: +c[2],
                            low: +c[3],
                            close: +c[4],
                            volume: +c[5]
                        }));
                        
                    case 'coincap':
                        return data.data.map(c => ({
                            openTime: new Date(c.time).getTime(),
                            open: +c.priceOpen,
                            high: +c.priceHigh,
                            low: +c.priceLow,
                            close: +c.priceClose,
                            volume: +c.volume
                        }));
                        
                    case 'kraken':
                        const pairKey = Object.keys(data.result)[0];
                        return data.result[pairKey].map(c => ({
                            openTime: c[0] * 1000,
                            open: +c[1],
                            high: +c[2],
                            low: +c[3],
                            close: +c[4],
                            volume: +c[6]
                        }));
                        
                    case 'huobi':
                        return data.data.map(c => ({
                            openTime: c.id * 1000,
                            open: +c.open,
                            high: +c.high,
                            low: +c.low,
                            close: +c.close,
                            volume: +c.vol
                        }));
                        
                    case 'okx':
                        return data.data.map(c => ({
                            openTime: +c[0],
                            open: +c[1],
                            high: +c[2],
                            low: +c[3],
                            close: +c[4],
                            volume: +c[5]
                        }));
                        
                    default:
                        throw new Error('Unknown API');
                }
            } catch (error) {
                console.error(`API ${api.name} error:`, error);
                throw error;
            }
        }

        function loadTradingViewWidget(containerId, symbol, interval) {
            if (typeof TradingView === 'undefined') {
                setTimeout(() => loadTradingViewWidget(containerId, symbol, interval), 200);
                return;
            }
            
            const tf = interval.replace('m', '').replace('h', 'H');
            
            if (tvWidgets[containerId]) {
                tvWidgets[containerId].symbolOrSearch(`BINANCE:${symbol}`);
                tvWidgets[containerId].setResolution(tf);
            } else {
                try {
                    tvWidgets[containerId] = new TradingView.widget({
                        autosize: true,
                        symbol: `BINANCE:${symbol}`,
                        interval: tf,
                        timezone: "Asia/Kolkata",
                        theme: "dark",
                        style: "1",
                        locale: "in",
                        toolbar_bg: "#0e1117",
                        enable_publishing: false,
                        allow_symbol_change: false,
                        container_id: containerId,
                        studies: [],
                    });
                } catch (e) {
                    console.warn('TradingView init failed', containerId, e);
                }
            }
        }

        function calculateUltimateSignals(closes, highs, lows, volumes, tf) {
            const price = closes.at(-1);
            const prevPrice = closes.at(-2) || price;
            const priceChange = ((price - prevPrice) / prevPrice) * 100;

            const rsi = calculateRSI(closes, 14);
            const ema9 = calculateEMA(closes, 9);
            const ema21 = calculateEMA(closes, 21);
            const ema50 = calculateEMA(closes, 50);
            const macd = calculateMACD(closes);
            const stochastic = calculateStochastic(highs, lows, closes);
            const bb = calculateBollingerBands(closes);
            const williamsR = calculateWilliamsR(highs, lows, closes);
            const cci = calculateCCI(highs, lows, closes);
            const obv = calculateOBV(closes, volumes);
            const prevObv = calculateOBV(closes.slice(0, -1), volumes.slice(0, -1));

            const lastVol = volumes.at(-1) || 0;
            const avgVol = sma(volumes.slice(-20));
            const volSpike = lastVol > avgVol * 1.5;
            const obvBullish = obv > prevObv;
                  // Buy Signals
            const buySignals = [];
            if (rsi < 25 && price < bb.lower) buySignals.push({ type: "RSI_OVERSOLD", confidence: 98 });
            if (macd.histogram > 0 && macd.macd > macd.signal && rsi < 35) buySignals.push({ type: "MACD_BULLISH", confidence: 90 });
            if (ema9 > ema21 && ema21 > ema50) buySignals.push({ type: "TREND_UP", confidence: 85 });
            if (stochastic.k < 20 && price < bb.lower * 1.02) buySignals.push({ type: "STOCH_OVERSOLD", confidence: 95 });
            if (volSpike && rsi < 40) buySignals.push({ type: "VOLUME_SPIKE", confidence: 80 });
            if (williamsR < -80) buySignals.push({ type: "WILLIAMS_OVERSOLD", confidence: 90 });
            if (cci < -100) buySignals.push({ type: "CCI_OVERSOLD", confidence: 85 });
            if (obvBullish && priceChange > 0) buySignals.push({ type: "OBV_BULLISH", confidence: 80 });

            // Sell Signals
            const sellSignals = [];
            if (rsi > 75 && price > bb.upper) sellSignals.push({ type: "RSI_OVERBOUGHT", confidence: 98 });
            if (macd.histogram < 0 && macd.macd < macd.signal && rsi > 65) sellSignals.push({ type: "MACD_BEARISH", confidence: 90 });
            if (ema9 < ema21 && ema21 < ema50) sellSignals.push({ type: "TREND_DOWN", confidence: 85 });
            if (stochastic.k > 80 && price > bb.upper * 0.98) sellSignals.push({ type: "STOCH_OVERBOUGHT", confidence: 95 });
            if (volSpike && rsi > 60) sellSignals.push({ type: "VOLUME_DUMP", confidence: 80 });
            if (williamsR > -20) sellSignals.push({ type: "WILLIAMS_OVERBOUGHT", confidence: 90 });
            if (cci > 100) sellSignals.push({ type: "CCI_OVERBOUGHT", confidence: 85 });
            if (!obvBullish && priceChange < 0) sellSignals.push({ type: "OBV_BEARISH", confidence: 80 });

            // Calculate Final Signal
            const totalBuyConfidence = buySignals.reduce((sum, sig) => sum + sig.confidence, 0) / Math.max(buySignals.length, 1);
            const totalSellConfidence = sellSignals.reduce((sum, sig) => sum + sig.confidence, 0) / Math.max(sellSignals.length, 1);

            let finalSignal = "NEUTRAL";
            let finalConfidence = 50;
            let signalType = "NEUTRAL";

            if (buySignals.length >= 6 && totalBuyConfidence >= 90) {
                finalSignal = "🚀 ULTRA BUY"; 
                finalConfidence = 99;
                signalType = "ULTRA_STRONG_BUY";
            } else if (sellSignals.length >= 6 && totalSellConfidence >= 90) {
                finalSignal = "🚨 ULTRA SELL"; 
                finalConfidence = 99;
                signalType = "ULTRA_STRONG_SELL";
            } else if (buySignals.length >= 4 && totalBuyConfidence >= 85) {
                finalSignal = "💯 STRONG BUY"; 
                finalConfidence = 95;
                signalType = "VERY_STRONG_BUY";
            } else if (sellSignals.length >= 4 && totalSellConfidence >= 85) {
                finalSignal = "💯 STRONG SELL"; 
                finalConfidence = 95;
                signalType = "VERY_STRONG_SELL";
            } else if (buySignals.length >= 2 && totalBuyConfidence >= 80) {
                finalSignal = "BUY";
                finalConfidence = 85;
                signalType = "STRONG_BUY";
            } else if (sellSignals.length >= 2 && totalSellConfidence >= 80) {
                finalSignal = "SELL";
                finalConfidence = 85;
                signalType = "STRONG_SELL";
            }

            return {
                price, rsi, ema9, ema21, ema50,
                macd: macd.macd, macdSignal: macd.signal, macdHistogram: macd.histogram,
                stochasticK: stochastic.k, stochasticD: stochastic.d,
                bbUpper: bb.upper, bbLower: bb.lower, bbMiddle: bb.middle,
                williamsR, cci, obv, obvBullish,
                volumeRatio: lastVol / avgVol, volumeSpike: volSpike,
                finalSignal, finalConfidence, signalType,
                buySignals, sellSignals,
                buyCount: buySignals.length,
                sellCount: sellSignals.length,
                totalSignals: buySignals.length + sellSignals.length
            };
        }

        function checkMultiTimeframeConfirmation() {
            const signals = {};
            timeframes.forEach(tf => {
                signals[tf] = multiTimeframeSignals[tf];
            });

            const ultraBuySignals = Object.values(signals).filter(s => s === 'ULTRA_STRONG_BUY').length;
            const ultraSellSignals = Object.values(signals).filter(s => s === 'ULTRA_STRONG_SELL').length;
            const strongBuySignals = Object.values(signals).filter(s => s === 'VERY_STRONG_BUY' || s === 'ULTRA_STRONG_BUY').length;
            const strongSellSignals = Object.values(signals).filter(s => s === 'VERY_STRONG_SELL' || s === 'ULTRA_STRONG_SELL').length;

            return {
                ultraMultiBuy: ultraBuySignals >= 2,
                ultraMultiSell: ultraSellSignals >= 2,
                strongMultiBuy: strongBuySignals >= 2,
                strongMultiSell: strongSellSignals >= 2,
                allUltraBuy: ultraBuySignals === timeframes.length,
                allUltraSell: ultraSellSignals === timeframes.length
            };
        }

        function setStrongState(tf, type, intensity = 'normal') {
            const s = strongState[tf];
            if (!s) return;
            
            const card = document.querySelector(`#dashboard .card-row[data-tf="${tf}"]`); 
            
            if (type === 'none') {
                s.state = 'none';
                s.start = null;
                s.intensity = 'normal';
                card?.classList.remove('strong-buy', 'strong-sell', 'very-strong-buy', 'very-strong-sell', 'ultra-strong-buy', 'ultra-strong-sell');
            } else {
                if (s.state !== type || s.intensity !== intensity) {
                    s.state = type;
                    s.intensity = intensity;
                    s.start = Date.now();
                    card?.classList.remove('strong-buy', 'strong-sell', 'very-strong-buy', 'very-strong-sell', 'ultra-strong-buy', 'ultra-strong-sell');

                    if (type === 'buy') {
                        if (intensity === 'ultra') card?.classList.add('ultra-strong-buy');
                        else if (intensity === 'very-strong') card?.classList.add('very-strong-buy');
                        else card?.classList.add('strong-buy');
                    } else if (type === 'sell') {
                        if (intensity === 'ultra') card?.classList.add('ultra-strong-sell');
                        else if (intensity === 'very-strong') card?.classList.add('very-strong-sell');
                        else card?.classList.add('strong-sell');
                    }
                }
            }
        }

        function updateTimersDisplay() {
            for (const tf of timeframes) {
                const el = document.getElementById(`timer-${tf}`);
                const s = strongState[tf];
                if (!el) continue;
                
                if (s.state === 'none') {
                    el.textContent = '';
                } else {
                    const diff = Date.now() - s.start;
                    const sec = Math.floor(diff / 1000);
                    const hh = Math.floor(sec / 3600);
                    const mm = Math.floor((sec % 3600) / 60);
                    const ss = sec % 60;
                    const fmt = (hh > 0 ? hh + ':' : '') + (mm < 10 ? '0' + mm : mm) + ':' + (ss < 10 ? '0' + ss : ss);
                    const intensityIcon = s.intensity === 'ultra' ? '🚀 ' : (s.intensity === 'very-strong' ? '💯 ' : '✅ ');
                    el.textContent = `⏱ ${intensityIcon}Signal Active: ${fmt}`;
                }
            }
        }

        function renderSignalDetails(signalData) {
            let html = `
                <h4>✅ Buy Signals (${signalData.buyCount} / 8)</h4>
                <div class="signal-list">
            `;
            signalData.buySignals.forEach(sig => {
                html += `<div class="signal-item buy">${sig.type}: <span class="conf">${sig.confidence}%</span></div>`;
            });
            html += `</div>`;

            html += `
                <h4>❌ Sell Signals (${signalData.sellCount} / 8)</h4>
                <div class="signal-list">
            `;
            signalData.sellSignals.forEach(sig => {
                html += `<div class="signal-item sell">${sig.type}: <span class="conf">${sig.confidence}%</span></div>`;
            });
            html += `</div>`;
            
            return html;
        }

        function renderDashboard() {
            dashboard.innerHTML = '';
            
            timeframes.forEach(tf => {
                const card = document.createElement('div');
                card.className = 'card-row';
                card.setAttribute('data-tf', tf);
                card.innerHTML = `
                    <div class="time-label">
                        ${tf.toUpperCase()} | <span id="time-${tf}">${new Date().toLocaleTimeString('en-IN', { hour12: false })}</span>
                        ${apiBadge(apiEndpoints[selectedAPI].name)}
                    </div>
                    <button class="details-button" data-tf="${tf}">Signal Details</button>
                    <div class="metric-group" id="metrics-${tf}">
                        <div class="metric-item">Loading...</div>
                    </div>
                    <div class="strong-timer" id="timer-${tf}"></div>
                    <div class="chart-container" id="tv-chart-${tf}">
                        <div>TradingView Chart Loading...</div>
                    </div>
                    <div class="signal-details-container" id="details-${tf}"></div>
                `;
                dashboard.appendChild(card);
                
                strongState[tf] = { state: 'none', start: null, intensity: 'normal' };
                loadTradingViewWidget(`tv-chart-${tf}`, selectedCoin, tf);
            });
        }

        function toggleSignalDetails(tf) {
            const detailsEl = document.getElementById(`details-${tf}`);
            detailsEl.classList.toggle('show');
            
            if (detailsEl.classList.contains('show') && allSignalsData[tf]) {
                detailsEl.innerHTML = renderSignalDetails(allSignalsData[tf]);
            } else if (detailsEl.classList.contains('show')) {
                detailsEl.innerHTML = `<h4>Loading Signal Data...</h4>`;
            }
        }

        async function updateTimeframe(tf, klines = null) {
            try {
                let data = klines;
                if (!data) data = await fetchKlines(tf, 500);
                
                const timeEl = document.getElementById(`time-${tf}`);
                if (timeEl) timeEl.textContent = new Date().toLocaleTimeString('en-IN', { hour12: false });
                
                const closes = data.map(k => k.close);
                const highs = data.map(k => k.high);
                const lows = data.map(k => k.low);
                const volumes = data.map(k => k.volume);

                currentPrice = closes.at(-1) || currentPrice;
                const signal = calculateUltimateSignals(closes, highs, lows, volumes, tf);
                
                allSignalsData[tf] = signal;
                
                const metricsEl = document.getElementById(`metrics-${tf}`);
                if (!metricsEl) return;

                multiTimeframeSignals[tf] = signal.signalType;

                let displaySignal = signal.finalSignal;
                let signalClass = 'yellow';
                let intensity = 'normal';
                let multiTFConfirm = '';

                if (signal.signalType === "ULTRA_STRONG_BUY") {
                    displaySignal = "🚀 ULTRA BUY"; signalClass = 'ultra-strong-green'; intensity = 'ultra';
                } else if (signal.signalType === "ULTRA_STRONG_SELL") {
                    displaySignal = "🚨 ULTRA SELL"; signalClass = 'ultra-strong-red'; intensity = 'ultra';
                } else if (signal.signalType === "VERY_STRONG_BUY") {
                    displaySignal = "💯 STRONG BUY"; signalClass = 'very-strong-buy'; intensity = 'very-strong';
                } else if (signal.signalType === "VERY_STRONG_SELL") {
                    displaySignal = "💯 STRONG SELL"; signalClass = 'very-strong-sell'; intensity = 'very-strong';
                } else if (signal.signalType === "STRONG_BUY") {
                    displaySignal = "BUY"; signalClass = 'green'; intensity = 'normal';
                } else if (signal.signalType === "STRONG_SELL") {
                    displaySignal = "SELL"; signalClass = 'red'; intensity = 'normal';
                }

                if (signal.signalType.includes('BUY')) {
                    setStrongState(tf, 'buy', intensity);
                } else if (signal.signalType.includes('SELL')) {
                    setStrongState(tf, 'sell', intensity);
                } else {
                    setStrongState(tf, 'none');
                }

                const multiTF = checkMultiTimeframeConfirmation();
                if (signal.signalType.includes('BUY')) {
                    if (multiTF.allUltraBuy) multiTFConfirm = '<span class="all-tf-confirm">ALL ULTRA ✓</span>';
                    else if (multiTF.ultraMultiBuy) multiTFConfirm = '<span class="multi-tf-confirm">ULTRA MULTI-TF ✓</span>';
                    else if (multiTF.strongMultiBuy) multiTFConfirm = '<span class="multi-tf-confirm">MULTI-TF ✓</span>';
                } else if (signal.signalType.includes('SELL')) {
                    if (multiTF.allUltraSell) multiTFConfirm = '<span class="all-tf-confirm">ALL ULTRA ✓</span>';
                    else if (multiTF.ultraMultiSell) multiTFConfirm = '<span class="multi-tf-confirm">ULTRA MULTI-TF ✓</span>';
                    else if (multiTF.strongMultiSell) multiTFConfirm = '<span class="multi-tf-confirm">MULTI-TF ✓</span>';
                }

                metricsEl.innerHTML = `
                    <div class="metric-item"><span class="label">Price</span>: <span class="value">$${signal.price.toFixed(2)}</span> / <span class="value">₹${(signal.price * usdToInr).toFixed(2)}</span></div>
                    <div class="metric-item"><span class="label">RSI</span>: <span class="value">${signal.rsi.toFixed(1)}</span> ${signalBadge(signal.rsi.toFixed(0), signal.rsi < 25 ? 'ultra-strong-green' : (signal.rsi < 30 ? 'very-strong-buy' : (signal.rsi > 75 ? 'ultra-strong-red' : (signal.rsi > 70 ? 'very-strong-sell' : 'yellow'))))}</div>
                    <div class="metric-item"><span class="label">MACD</span>: <span class="value">${signal.macdHistogram > 0 ? '▲' : '▼'}</span> ${signalBadge('', signal.macdHistogram > 0 ? 'green' : 'red')}</div>
                    <div class="metric-item"><span class="label">STOCH</span>: <span class="value">${signal.stochasticK.toFixed(0)}</span> ${signalBadge('', signal.stochasticK < 15 ? 'ultra-strong-green' : (signal.stochasticK < 20 ? 'very-strong-buy' : (signal.stochasticK > 85 ? 'ultra-strong-red' : (signal.stochasticK > 80 ? 'very-strong-sell' : 'yellow'))))}</div>
                    <div class="metric-item"><span class="label">Williams %R</span>: <span class="value">${signal.williamsR.toFixed(0)}</span> ${signalBadge('', signal.williamsR < -80 ? 'ultra-strong-green' : (signal.williamsR > -20 ? 'ultra-strong-red' : 'yellow'))}</div>
                    <div class="metric-item"><span class="label">CCI</span>: <span class="value">${signal.cci.toFixed(0)}</span> ${signalBadge('', signal.cci < -100 ? 'ultra-strong-green' : (signal.cci > 100 ? 'ultra-strong-red' : 'yellow'))}</div>
                    <div class="metric-item"><span class="label">Volume</span>: <span class="value">${signal.volumeRatio > 1 ? '▲' : '▼'}</span> ${signalBadge(signal.volumeSpike ? 'SPIKE' : 'NORM', signal.volumeSpike ? 'very-strong-buy' : 'yellow')}</div>
                    <div class="metric-item"><span class="label">OBV</span>: <span class="value">${signal.obvBullish ? '▲' : '▼'}</span> ${signalBadge('', signal.obvBullish ? 'green' : 'red')}</div>
                    <div class="metric-item" style="flex:0 0 100%;text-align:center;margin-top:4px;">
                        <span class="value" style="font-size:14px;${signalClass}">${displaySignal}</span>
                        ${signalBadge(signal.finalConfidence + '%', signalClass)}
                        ${multiTFConfirm}
                    </div>
                    <div class="metric-item" style="flex:0 0 100%;font-size:10px;color:#9ca3af;text-align:center;">
                        Signals: ${signal.buyCount}✅ / ${signal.sellCount}❌ | Total: ${signal.totalSignals}
                    </div>
                `;

            } catch (e) {
                console.error(`Error updating ${tf}:`, e);
                const metricsEl = document.getElementById(`metrics-${tf}`);
                if (metricsEl) {
                    metricsEl.innerHTML = `<div class="metric-item" style="color:#ef4444">❌ ${apiEndpoints[selectedAPI].name} API Error</div>`;
                }
            }
        }

        async function updateAllTimeframes() {
            try {
                const allData = {};
                for (const tf of timeframes) {
                    allData[tf] = await fetchKlines(tf, 500);
                }
                
                for (const tf of timeframes) {
                    await updateTimeframe(tf, allData[tf]);
                }
                
                tickCounter++;
                const api = apiEndpoints[selectedAPI];
                statusEl.innerHTML = `<span style="color:#10b981">✅ ${api.name} LIVE DATA (${tickCounter}) - ${api.limit}/min limit</span>`;
            } catch (e) {
                console.error('Error updating all timeframes:', e);
                statusEl.innerHTML = `<span style="color:#ef4444">❌ ${apiEndpoints[selectedAPI].name} CONNECTION ERROR</span>`;
            }
        }

        function initializeCoinSelector() {
            coins.forEach(coin => {
                const option = document.createElement('option');
                option.value = coin;
                option.textContent = coin;
                if (coin === selectedCoin) option.selected = true;
                coinSelect.appendChild(option);
            });
        }

        function setupEventListeners() {
            coinSelect.addEventListener('change', (e) => {
                selectedCoin = e.target.value;
                renderDashboard();
                updateAllTimeframes();
            });
            
            apiSelect.addEventListener('change', (e) => {
                selectedAPI = e.target.value;
                renderDashboard();
                updateAllTimeframes();
            });
            
            dashboard.addEventListener('click', (e) => {
                if (e.target.classList.contains('details-button')) {
                    const tf = e.target.getAttribute('data-tf');
                    toggleSignalDetails(tf);
                }
            });
        }

        function initializeApp() {
            initializeCoinSelector();
            renderDashboard();
            setupEventListeners();
            updateAllTimeframes();
            
            setInterval(updateAllTimeframes, 5000);
            setInterval(updateTimersDisplay, 1000);
        }

        initializeApp();
    </script>
</body>
</html>